
from astropy.io import fits
from astropy.nddata import NDData
from astropy.table import Table
from astropy.wcs import wcs
import astropy.units as u
import numpy as np
import os
from astropy import log
from astropy import __version__
from astropy.vo.samp import SAMPIntegratedClient
from urlparse import urlparse, urljoin
import time
import tempfile
from ..core import adata as dt

def create(name):
   ws=dict()
   ws['workspace']=name
   return ws

_ws_df=create("DEFAULT")

#def send(name,ws=_ws_df,destination='all'):
#   _send(ws[name],name,destination)

def elements(ws=_ws_df):
   retval=ws.copy()
   del retval['workspace']
   return retval

def _create_cube(data,meta):
   """ data = numpy data
       meta = header of fits
   """
   mask=np.isnan(data)
   try:
     bscale=meta['BSCALE']
   except KeyError:
     bscale=1.0
   try:
     bzero=meta['BZERO']
   except KeyError:
     bzero=0.0
   try:
     bsu=meta['BUNIT']
     bsu=bsu.lower()
     bsu=bsu.replace("jy","Jy")
     bunit=u.Unit(bsu,format="fits")
   except KeyError:
     bunit=u.Unit("u.Jy/u.beam")
   # Hack to correct wrong uppercased units generated by CASA

   # Create astropy units
   if len(data.shape) != 4:
       log.error("Only 4D FITS (RA-DEC-FREQ-STOKES) are allowed (like CASA-generated ones). Talk to the core team to include your datatype.")
       raise TypeError

   # Put data in physically-meaninful values, and remove stokes
   # TODO: Stokes is removed by summing (is this correct? maybe is averaging?)
   data=data.sum(axis=0)*bscale+bzero
   mywcs=wcs.WCS(meta)
   mywcs=mywcs.dropaxis(3)
   return dt.AData(data,mywcs,meta,bunit)

def _fits_consumer(path,name,ws=_ws_df):
#TODO: Support more filetypes
   wname=ws['workspace']
   log.info("Loading "+name+".fits into "+wname)
   hdulist = fits.open(path)
   counter=0
   for hdu in hdulist:
      if isinstance(hdu,fits.PrimaryHDU) or isinstance(hdu,fits.ImageHDU):
         log.info("Processing HDU "+str(counter)+" (Image)")
         ndd=_create_cube(hdu.data,hdu.header)
         ide=name+"-"+str(counter)
         ws[ide]=ndd

         #print ndd.get_flux()
         ### SCALE DATA TEST ###

         #scale = ndd.scale(2)
         
         #scale = _create_cube(np.array([scale]), hdu.header)
         #print scale.get_flux()  ## SAME FLUX
         counter+=1
         #ide = name+"-"+str(counter)
         #ws[ide] = scale


         ### CUT DATA TEST ####
         #cut = ndd.get_slice((50,50,50))
         #cut = cb.Cube(cut, hdu.header)
         #counter+=1
         #ide=name+"-"+str(counter)
         #ws[ide]=cut

         ### END CUT DATA TEST ####

         ### ROTATE DATA TEST ###
         #rot = ndd.rotate(45)
         #counter+=1
         #ide=name+"-"+str(counter)
         #ws[ide]=rot         

      elif isinstance(hdu,fits.BinTableHDU) or isinstance(hdu,fits.TableHDU):
         log.info("Processing HDU "+str(counter)+" (Table)")
          #TODO: check for WCS data...
         ntt=Table(hdu.data,meta=hdu.header)
         ide=name+"-"+str(counter)
         ws[ide]=ntt
      else:
         log.warning("HDU type not recognized, ignoring "+hdu.name+" ("+counter+")")
      counter+=1

def _hdf5_consumer(path,name,ws):
   log.warning("HDF5 format not supported yet. Ignoring file "+name+".hdf5")
def _votable_consumer(path,name,ws):
   log.warning("VOTable format not supported yet. Ignoring file "+name+".xml")
def _ascii_consumer(path,name,ws):
   log.warning("ASCII format not supported yet. Ignoring file "+name)

def import_file(path,ws=_ws_df):
   filename=os.path.basename(path)
   name,ext=os.path.splitext(filename)
   if ext == '.fits':
      _fits_consumer(path,name,ws)
   elif ext == '.hdf5':
      _hdf5_consumer(path,name,ws)
   elif ext == '.xml':
      _votable_consumer(path,name,ws)
   else:
      _ascii_consumer(path,name,ws)

def real_dims(ndd):
   shape=[]
   dim=0

   for i in range(ndd.data.ndim):
      if ndd.data.shape[i] != 1:
         shape.append(ndd.data.shape[i])
         dim+=1
   if dim==1:
      otype="Spectra"
   elif dim==2:
      otype="Image"
   elif dim>=3:
      otype="Cube"
   else:
      log.warning("NDData of 0 dimension? ignoring...")
      return
   return (dim,shape,otype)


def send_aladin(fit,name):

    """
    Sends data to aladin
    fits only supported
    """
    #fitPath = os.path.splitext(fit)[0]
    fitExtension = os.path.splitext(fit)[1]

    if (fitExtension != ".fits"): # for now, next with exceptions
        print "Please use a file with .fits extension"
        return

    client = SAMPIntegratedClient()
    client.connect()

    params = {}
    params["url"] = 'file://' + fit
    params["name"] = name

    message = {}
    message["samp.mtype"] = "image.load.fits"
    message["samp.params"] = params

    client.notify_all(message) # the easiest way is notify all

    client.disconnect()


#def declare_metadata(client):
#
#    metadata = {"samp.name": "astropy",
#                "samp.description.text": "The Astropy Project",
#                "samp.icon.url": client.client._xmlrpcAddr + "/samp/icon",
#                "samp.documentation.url": "http://docs.astropy.org/en/stable/vo/samp",
#                "author.name": "The Astropy Collaboration",
#                "home.page": "http://www.astropy.org",
#                "astropy.version": __version__
#                }

#    client.declare_metadata(metadata)

#This function was copied from a astropy development branch, please remove it when highlevel commands become available
#def _send(data, name, destination='all', timeout=10, hub=None):
#    """
#    Send data to SAMP clients.
#
#    Parameters
#    ----------
#    data : `~astropy.table.table.Table` or `~astropy.nddata.nddata.NDData` or `~numpy.ndarray` or `~astropy.io.fits.PrimaryHDU` or `~astropy.io.fits.ImageHDU` or `~astropy.io.fits.BinTableHDU` or `~astropy.io.fits.TableHDU`
#        The data to send over SAMP
#    name : str, optional
#        The name of the dataset to use in other SAMP clients
#    destination : str, optional
#        The client to send the data to. By default, the data is broadcast to
#        all SAMP clients. You can find the full list of available clients, use
#        the :func:`~astropy.vo.samp.high_level.list_clients` function. As a
#        convenience, you can also use ``'ds9'``, ``'topcat'``, and ``aladin'``
#        and :func:`~astropy.vo.samp.high_level.send` will try and identify the
#        correct client.
#    timeout : int, optional
#        The timeout for the request.
#    hub : `~astropy.vo.samp.hub.SAMPHubServer`, optional
#        The hub to send the data through
#    """
#
#    message = {}
#    output_file = tempfile.NamedTemporaryFile()
#
#    if isinstance(data, Table):
#
#        data.write(output_file, format='votable')
#        message['samp.mtype'] = "table.load.votable"
#
#    elif isinstance(data, NDData):
#
#        fits.writeto(output_file, data.data)
#        #data.write(output_file, format='fits')
#        message['samp.mtype'] = "image.load.fits"
#
#    elif isinstance(data, np.ndarray):
#
#        if data.dtype.fields is None:
#            fits.writeto(output_file, data)
#            message['samp.mtype'] = "image.load.fits"
#        else:
#            data = Table(data)
#            data.write(output_file, format='votable')
#            message['samp.mtype'] = "table.load.votable"
#
#    elif isinstance(data, (fits.ImageHDU, fits.PrimaryHDU)):
#
#        data.writeto(output_file)
#        message['samp.mtype'] = "image.load.fits"
#
#    elif isinstance(data, (fits.BinTableHDU, fits.TableHDU)):
#
#        data.writeto(output_file)
#        message['samp.mtype'] = "table.load.fits"
#
#    else:
#
#        raise TypeError("Unrecognized data type: {0}".format(type(data)))
#
#    message['samp.params'] = {"url": urljoin('file:', output_file.name),
#                              "name": name}
#
#    client = SAMPIntegratedClient()
#    client.connect(hub=hub)
#    declare_metadata(client)
#
#    try:
#       if destination == 'all':
#           for c in client.get_subscribed_clients(message['samp.mtype']):
#               client.call_and_wait(c, message, timeout=str(timeout))
#       elif destination in ['ds9', 'topcat', 'aladin']:
#           clients = list_clients()
#           for target_client in clients:
#               name = target_client['name']
#               if destination in name.lower():
#                   client.call_and_wait(str(target_client['id']), message,
#                                        timeout=str(timeout))
#       else:
#           client.call_and_wait(destination, message, timeout=str(timeout))
#    except:
#       pass
#
#    client.disconnect()
#
#    output_file.close()


